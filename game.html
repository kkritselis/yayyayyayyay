<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yay! Yay! Yay! Yay!</title>
    <style>
        body { 
            background:#111; 
            color:#fff; 
            font-family:sans-serif; 
            display:flex; 
            flex-direction:column; 
            align-items:center;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 { 
            font-size: clamp(24px, 5vw, 32px);
            margin: 10px 0;
            text-align: center;
        }
        h2 {
            font-size: clamp(18px, 4vw, 24px);
            margin: 5px 0 15px 0;
            text-align: center;
        }
        #container { 
            display: flex; 
            gap: 20px; 
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 800px;
        }
        .circleBox, .slots { 
            background: #222; 
            padding: 10px; 
            border-radius: 8px; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 10px; 
            width: min(250px, calc(100% - 20px));
            min-height: 60px;
            justify-content: center;
            align-content: flex-start;
        }
        .circle { 
            cursor: grab; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            position: relative;
            width: 80px;
            height: 80px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 5px;
            border: 1px solid #333;
        }
        .circle canvas {
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            background: transparent;
        }
        .circle.dragging { 
            opacity: 0.9; 
            position: fixed; 
            pointer-events: none; 
            z-index: 1000; 
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .slot { 
            width: 80px; 
            height: 80px; 
            border: 2px dashed #555; 
            border-radius: 8px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: #888; 
            font-size: 12px;
            background: #1a1a1a;
            padding: 0;
            position: relative;
            overflow: hidden;
        }
        .slot canvas {
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            display: none;
        }
        .slot.filled canvas {
            display: block;
        }
        .slot.filled .placeholder {
            display: none;
        }
        .slot .placeholder {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }
        .slot.dragover:not(.locked) { 
            border-color: #fff; 
            background: rgba(255,255,255,0.1);
        }
        .slot.locked {
            pointer-events: none;
            opacity: 0.8;
        }
        canvas { 
            background: #000; 
            border: 4px solid #444; 
            margin: 20px 0;
            transition: border 0.3s, box-shadow 0.3s;
            max-width: 100%;
            height: auto;
        }
        #message { 
            font-size: clamp(18px, 4vw, 24px);
            margin: 10px; 
            opacity: 0; 
            transition: opacity 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            white-space: pre-line;
        }
        #nextBtn, #solveBtn { 
            padding: 10px 20px; 
            background: #0f0; 
            color: #000; 
            border: none; 
            border-radius: 6px; 
            font-size: clamp(16px, 3vw, 18px);
            cursor: pointer; 
            margin: 5px;
            display: none;
            min-width: 120px;
        }
        #nextBtn:hover, #solveBtn:hover { 
            background: #7f7;
        }
        #historyPanel {
            background: #222;
            border-radius: 8px;
            padding: 15px;
            margin: 20px auto;
            width: 100%;
            max-width: 800px;
        }

        .attempt {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid #444;
            animation: fadeIn 0.3s ease-out;
        }

        .attempt:last-child {
            border-bottom: none;
        }

        .attempt-circles {
            display: flex;
            gap: 5px;
        }

        .attempt-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid #0008;
        }

        .feedback-dots {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }

        .feedback-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid #fff4;
        }

        .feedback-dot.correct-place {
            background: #0f0;
        }

        .feedback-dot.correct-wrong-place {
            background: #ff0;
        }

        .feedback-dot.wrong {
            background: #444;
        }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            padding: 10px;
            border-bottom: 1px solid #444;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 600px) {
            #container {
                gap: 10px;
            }
            .circleBox, .slots {
                width: 100%;
                max-width: none;
            }
            .circle {
                width: 40px;
                height: 40px;
            }
            .circle canvas {
                width: 40px;
                height: 40px;
            }
            .slot {
                width: 40px;
                height: 40px;
            }
            .slot canvas {
                width: 40px;
                height: 40px;
            }
            canvas {
                width: 100%;
                max-height: 50vh;
            }
            .attempt {
                flex-wrap: wrap;
            }
            .feedback-dots {
                margin-left: 0;
                margin-top: 5px;
            }
            .attempt-circle {
                width: 15px;
                height: 15px;
            }
            .feedback-dot {
                width: 8px;
                height: 8px;
            }
        }
    </style>
</head>
<body>
<div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 800px; margin-bottom: 20px;">
  <a href="index.html">
    <img src="logo_sub.png" alt="Yay! Yay! Yay! Yay!" style="width: 100%;">
  </a>
</div>

<div id="container">
  <div class="circleBox" id="circleBox"></div>
  <div class="slots" id="slots"></div>
</div>

<canvas id="canvas" width="400" height="350"></canvas>

<div id="historyPanel">
  <div class="legend">
    <div class="legend-item">
      <div class="feedback-dot correct-place"></div>
      <span>Correct position</span>
    </div>
    <div class="legend-item">
      <div class="feedback-dot correct-wrong-place"></div>
      <span>Correct circle, wrong position</span>
    </div>
    <div class="legend-item">
      <div class="feedback-dot wrong"></div>
      <span>Wrong circle</span>
    </div>
  </div>
  <div id="attemptsHistory"></div>
</div>

<div id="message">Correct!</div>
<div>
  <button id="nextBtn">Next Level</button>
  <button id="solveBtn">Show Solution</button>
</div>

<script>
    //--------- LEVEL DATA
const levels = [
  {
    "name": "Ellipse",
    "target": [
      { "id": "c1", "color": "#0f0", "r": 80, "f": 1, "p": 0 },
      { "id": "c2", "color": "#ff0", "r": 40, "f": -1, "p": 1.2 }
    ],
    "decoys": [
      { "id": "d1", "color": "#f44", "r": 60, "f": 3, "p": 0.8 },
      { "id": "d2", "color": "#fa0", "r": 30, "f": 2, "p": 1.57 }
    ]
  },
  {
    "name": "Figure Eight",
    "target": [
      { "id": "c1", "color": "#0ff", "r": 70, "f": 1, "p": 0 },
      { "id": "c2", "color": "#fa0", "r": 30, "f": 2, "p": 1.57 }
    ],
    "decoys": [
      { "id": "d1", "color": "#4af", "r": 40, "f": -3, "p": 1.3 },
      { "id": "d2", "color": "#f0f", "r": 40, "f": 3, "p": 1.2 }
    ]
  },
  {
    "name": "Trefoil Knot",
    "target": [
      { "id": "c1", "color": "#0f0", "r": 70, "f": 1, "p": 0 },
      { "id": "c2", "color": "#f0f", "r": 40, "f": 3, "p": 1.2 },
      { "id": "c3", "color": "#ff0", "r": 20, "f": -2, "p": 0.6 }
    ],
    "decoys": [
      { "id": "d1", "color": "#a44", "r": 50, "f": -4, "p": 2.0 },
      { "id": "d2", "color": "#ff0", "r": 15, "f": 3, "p": 0.5 }
    ]
  },
  {
    "name": "Heart",
    "target": [
      { "id": "c1", "color": "#f33", "r": 60, "f": 1, "p": 0 },
      { "id": "c2", "color": "#f0f", "r": 30, "f": -2, "p": 1.2 },
      { "id": "c3", "color": "#ff0", "r": 15, "f": 3, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d1", "color": "#0ff", "r": 40, "f": -3, "p": 1.0 },
      { "id": "d2", "color": "#0f0", "r": 30, "f": -4, "p": 1.5 }
    ]
  },
  {
    "name": "Star (5-point)",
    "target": [
      { "id": "c1", "color": "#ff0", "r": 70, "f": 5, "p": 0 },
      { "id": "c2", "color": "#0f0", "r": 30, "f": -4, "p": 1.5 }
    ],
    "decoys": [
      { "id": "d1", "color": "#f44", "r": 50, "f": 2, "p": 0.7 },
      { "id": "d2", "color": "#fa0", "r": 20, "f": -2, "p": 1.2 }
    ]
  },
  {
    "name": "Clover (3 leaves)",
    "target": [
      { "id": "c1", "color": "#0f0", "r": 50, "f": 3, "p": 0 },
      { "id": "c2", "color": "#fa0", "r": 20, "f": -2, "p": 1.2 }
    ],
    "decoys": [
      { "id": "d1", "color": "#a44", "r": 35, "f": 4, "p": 0.9 },
      { "id": "d2", "color": "#f0f", "r": 40, "f": 3, "p": 1.57 }
    ]
  },
  {
    "name": "Lissajous Curve",
    "target": [
      { "id": "c1", "color": "#0ff", "r": 60, "f": 2, "p": 0 },
      { "id": "c2", "color": "#f0f", "r": 40, "f": 3, "p": 1.57 }
    ],
    "decoys": [
      { "id": "d1", "color": "#f44", "r": 50, "f": -1, "p": 0.8 },
      { "id": "d2", "color": "#ff0", "r": 30, "f": 2, "p": 1.5 }
    ]
  },
  {
    "name": "Infinity Symbol",
    "target": [
      { "id": "c1", "color": "#0f0", "r": 70, "f": 1, "p": 0 },
      { "id": "c2", "color": "#ff0", "r": 30, "f": 2, "p": 1.5 }
    ],
    "decoys": [
      { "id": "d1", "color": "#f44", "r": 40, "f": -3, "p": 1.2 },
      { "id": "d2", "color": "#f0f", "r": 15, "f": 4, "p": 1.0 }
    ]
  },
  {
    "name": "Waveform (Sine Stack)",
    "target": [
      { "id": "c26", "color": "#0ff", "r": 50, "f": 1, "p": 0 },
      { "id": "c27", "color": "#ff0", "r": 30, "f": 2, "p": 0.5 },
      { "id": "c28", "color": "#f0f", "r": 15, "f": 4, "p": 1.0 }
    ],
    "decoys": [
      { "id": "d1", "color": "#f44", "r": 45, "f": -3, "p": 2.0 },
      { "id": "d2", "color": "#f0f", "r": 10, "f": 7, "p": 0.5 }
    ]
  },
  {
    "name": "Complex Flower",
    "target": [
      { "id": "c40", "color": "#0f0", "r": 60, "f": 3, "p": 0 },
      { "id": "c41", "color": "#ff0", "r": 30, "f": 5, "p": 1.0 },
      { "id": "c42", "color": "#0ff", "r": 20, "f": -4, "p": 2.1 },
      { "id": "c43", "color": "#f0f", "r": 10, "f": 7, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d40", "color": "#fa0", "r": 25, "f": -5, "p": 1.3 },
      { "id": "c51", "color": "#0ff", "r": 15, "f": -5, "p": 0.8 }
    ]
  },
  {
    "name": "Celtic Knot",
    "target": [
      { "id": "c48", "color": "#0f0", "r": 50, "f": 2, "p": 0 },
      { "id": "c49", "color": "#ff0", "r": 35, "f": -3, "p": 1.7 },
      { "id": "c50", "color": "#f0f", "r": 25, "f": 4, "p": 3.1 },
      { "id": "c51", "color": "#0ff", "r": 15, "f": -5, "p": 0.8 }
    ],
    "decoys": [
      { "id": "d42", "color": "#4af", "r": 40, "f": 2, "p": 2.0 },
      { "id": "c55", "color": "#f0f", "r": 15, "f": -4, "p": 0.5 }
    ]
  },
  {
    "name": "Orbit Rings",
    "target": [
      { "id": "c52", "color": "#0f0", "r": 70, "f": 1, "p": 0 },
      { "id": "c53", "color": "#ff0", "r": 50, "f": -2, "p": 1.3 },
      { "id": "c54", "color": "#0ff", "r": 30, "f": 3, "p": 2.2 },
      { "id": "c55", "color": "#f0f", "r": 15, "f": -4, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d43", "color": "#fa0", "r": 20, "f": -3, "p": 1.0 },
      { "id": "c59", "color": "#f0f", "r": 10, "f": -6, "p": 0.7 }
    ]
  },
  {
    "name": "Four Leaf Clover",
    "target": [
      { "id": "c56", "color": "#0f0", "r": 50, "f": 4, "p": 0 },
      { "id": "c57", "color": "#fa0", "r": 30, "f": -3, "p": 1.2 },
      { "id": "c58", "color": "#0ff", "r": 20, "f": 5, "p": 2.5 },
      { "id": "c59", "color": "#f0f", "r": 10, "f": -6, "p": 0.7 }
    ],
    "decoys": [
      { "id": "d44", "color": "#f44", "r": 25, "f": 3, "p": 2.1 },
      { "id": "c63", "color": "#0f0", "r": 15, "f": -4, "p": 0.4 }
    ]
  },
  {
    "name": "Chaos Star",
    "target": [
      { "id": "c60", "color": "#ff0", "r": 60, "f": 7, "p": 0 },
      { "id": "c61", "color": "#0ff", "r": 30, "f": -6, "p": 1.1 },
      { "id": "c62", "color": "#f0f", "r": 20, "f": 5, "p": 2.8 },
      { "id": "c63", "color": "#0f0", "r": 15, "f": -4, "p": 0.4 }
    ],
    "decoys": [
      { "id": "d45", "color": "#fa0", "r": 25, "f": 2, "p": 1.3 },
      { "id": "c67", "color": "#0f0", "r": 10, "f": 4, "p": 0.9 }
    ]
  },
  {
    "name": "Wave Interference",
    "target": [
      { "id": "c64", "color": "#0ff", "r": 55, "f": 1, "p": 0 },
      { "id": "c65", "color": "#f0f", "r": 35, "f": 2, "p": 1.7 },
      { "id": "c66", "color": "#ff0", "r": 25, "f": -3, "p": 2.9 },
      { "id": "c67", "color": "#0f0", "r": 10, "f": 4, "p": 0.9 }
    ],
    "decoys": [
      { "id": "d46", "color": "#4af", "r": 20, "f": -5, "p": 0.6 },
      { "id": "c71", "color": "#0f0", "r": 10, "f": -5, "p": 0.3 }
    ]
  },
  {
    "name": "Radiant Sun",
    "target": [
      { "id": "c68", "color": "#ff0", "r": 70, "f": 8, "p": 0 },
      { "id": "c69", "color": "#fa0", "r": 40, "f": -7, "p": 1.4 },
      { "id": "c70", "color": "#f0f", "r": 20, "f": 6, "p": 2.3 },
      { "id": "c71", "color": "#0f0", "r": 10, "f": -5, "p": 0.3 }
    ],
    "decoys": [
      { "id": "d47", "color": "#0ff", "r": 25, "f": 3, "p": 2.0 },
      { "id": "c75", "color": "#0ff", "r": 10, "f": -5, "p": 0.8 }
    ]
  },
  {
    "name": "Entangled Loops",
    "target": [
      { "id": "c72", "color": "#0f0", "r": 65, "f": 2, "p": 0 },
      { "id": "c73", "color": "#ff0", "r": 40, "f": -3, "p": 1.6 },
      { "id": "c74", "color": "#f0f", "r": 20, "f": 4, "p": 2.7 },
      { "id": "c75", "color": "#0ff", "r": 10, "f": -5, "p": 0.8 }
    ],
    "decoys": [
      { "id": "d48", "color": "#fa0", "r": 30, "f": 3, "p": 1.2 },
      { "id": "c79", "color": "#0f0", "r": 10, "f": 4, "p": 0.5 }
    ]
  },
  {
    "name": "Quad Infinity",
    "target": [
      { "id": "c76", "color": "#0ff", "r": 60, "f": 1, "p": 0 },
      { "id": "c77", "color": "#f0f", "r": 40, "f": 2, "p": 1.3 },
      { "id": "c78", "color": "#ff0", "r": 20, "f": -3, "p": 2.5 },
      { "id": "c79", "color": "#0f0", "r": 10, "f": 4, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d49", "color": "#f44", "r": 25, "f": -2, "p": 1.5 },
      { "id": "c75", "color": "#0ff", "r": 10, "f": -5, "p": 0.8 }
    ]
  }
];

let currentLevel = 0;
let circles = [];
let targetPoints = [];
let t = 0;
let glowTimer = 0;
let attempts = [];

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const box = document.getElementById("circleBox");
const slotContainer = document.getElementById("slots");
const message = document.getElementById("message");
const nextBtn = document.getElementById("nextBtn");
const solveBtn = document.getElementById("solveBtn");

//----- LOAD LEVEL
function loadLevel(n) {
  const L = levels[n];
  
  // Compute target points first
  computeTarget(L.target);
  
  // Clear all animations first
  const allCanvases = document.querySelectorAll('.circle canvas, .slot canvas');
  allCanvases.forEach(canvas => {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });

  box.innerHTML = "";
  slotContainer.innerHTML = "";
  nextBtn.style.display = "none";
  solveBtn.style.display = "none"; // Hide solve button initially
  canvas.style.boxShadow = "none";
  document.getElementById('attemptsHistory').innerHTML = "";
  attempts = [];
  
  // Stop main canvas drawing (and show target shape)
  stopDrawing();

  // Use exactly the number of target circles needed for this level
  const targetCircles = L.target;
  
  // Use exactly 2 decoys
  const decoyCircles = L.decoys.slice(0, 2);

  // Merge target + decoys and shuffle
  circles = [...targetCircles, ...decoyCircles].sort(() => Math.random() - 0.5);

  // Create draggable circles with animated previews
  circles.forEach(c => {
    const div = document.createElement("div");
    div.className = "circle";
    div.draggable = true;
    div.dataset.id = c.id;
    
    // Create preview canvas
    const canvas = document.createElement("canvas");
    // Use smaller canvas on mobile
    const isMobile = window.innerWidth <= 600;
    canvas.width = isMobile ? 40 : 80;
    canvas.height = isMobile ? 40 : 80;
    div.appendChild(canvas);

    // Function to create animation context
    const createAnimation = (targetCanvas) => {
      const ctx = targetCanvas.getContext("2d");
      let t = 0;
      let animationId;
      const isMobile = window.innerWidth <= 600;
      const size = isMobile ? 40 : 80;
      const center = size / 2;
      const scale = isMobile ? 0.2 : 0.4; // Adjust scale for mobile
      
      const animate = () => {
        ctx.clearRect(0, 0, size, size);
        ctx.save();
        ctx.translate(center, center);
        
        // Draw orbit path
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        for (let i = 0; i < 30; i++) {
          const angle = (i / 30) * Math.PI * 2;
          const x = c.r * scale * Math.cos(c.f * angle + c.p);
          const y = c.r * scale * Math.sin(c.f * angle + c.p);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
        
        // Draw moving point
              const x = c.r * scale * Math.cos(c.f * t + c.p);
      const y = c.r * scale * Math.sin(c.f * t + c.p);
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        t += 0.1;
        animationId = requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
      
      // Return function to stop animation
      return () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
      };
    };

    // Start animation for the original circle
    const stopAnimation = createAnimation(canvas);

    // Desktop drag events
    div.addEventListener("dragstart", e => {
      e.dataTransfer.setData("id", c.id);
      const clone = canvas.cloneNode(true);
      e.dataTransfer.setDragImage(clone, 40, 40);
    });

    // Cleanup when element is removed
    div.addEventListener("remove", () => {
      stopAnimation();
    });

    // Mobile touch events
    div.addEventListener("touchstart", e => {
        if (e.cancelable) e.preventDefault();
        const touch = e.touches[0];
        const clone = div.cloneNode(true);
        clone.className = "circle dragging";
        document.body.appendChild(clone);
        
        // Start animation in the clone
        const stopCloneAnimation = createAnimation(clone.querySelector('canvas'));
        
        const moveCircle = (moveEvent) => {
            if (moveEvent.cancelable) moveEvent.preventDefault();
            const moveTouch = moveEvent.touches[0];
            clone.style.left = moveTouch.pageX + "px";
            clone.style.top = moveTouch.pageY + "px";
            
            // Find slot under touch point
            const slots = document.querySelectorAll(".slot:not(.locked)");
            slots.forEach(slot => slot.classList.remove("dragover"));
            
            const touchTarget = document.elementFromPoint(moveTouch.pageX, moveTouch.pageY);
            const slot = touchTarget?.closest(".slot:not(.locked)");
            if (slot) slot.classList.add("dragover");
        };
        
        const endTouch = (endEvent) => {
            if (endEvent.cancelable) endEvent.preventDefault();
            const endTouch = endEvent.changedTouches[0];
            const dropTarget = document.elementFromPoint(endTouch.pageX, endTouch.pageY);
            const slot = dropTarget?.closest(".slot:not(.locked)");
            
            if (slot) {
                // Clear the slot completely
                slot.innerHTML = '';
                slot.classList.remove("dragover");
                slot.dataset.id = c.id;
                slot.classList.add("filled");
                
                // Create new canvas
                const canvas = document.createElement('canvas');
                const isMobile = window.innerWidth <= 600;
                canvas.width = isMobile ? 40 : 80;
                canvas.height = isMobile ? 40 : 80;
                canvas.style.cssText = "width: 100%; height: 100%; display: block;";
                slot.appendChild(canvas);
                createAnimation(canvas);
                
                slot.style.border = "2px solid #fff";
            }
            
            stopCloneAnimation();
            clone.remove();
            document.removeEventListener("touchmove", moveCircle);
            document.removeEventListener("touchend", endTouch);
        };
        
        document.addEventListener("touchmove", moveCircle);
        document.addEventListener("touchend", endTouch);
    });

    box.appendChild(div);
  });

  // Create slots based on target count
  const targetCount = L.target.length;
  for (let i = 0; i < targetCount; i++) {
    const slot = document.createElement("div");
    slot.className = "slot";
    
    // Add placeholder text
    const placeholder = document.createElement("div");
    placeholder.className = "placeholder";
    placeholder.innerText = "drop";
    slot.appendChild(placeholder);
    
    // Add canvas for animation
    const canvas = document.createElement("canvas");
    // Use smaller canvas on mobile
    const isMobile = window.innerWidth <= 600;
    canvas.width = isMobile ? 40 : 80;
    canvas.height = isMobile ? 40 : 80;
    const ctx = canvas.getContext("2d");
    slot.appendChild(canvas);
    
    let animation = null;
    let currentCircle = null;

    const startAnimation = (circle) => {
      if (animation) cancelAnimationFrame(animation);
      currentCircle = circle;
      let t = 0;
      
      const animate = () => {
        ctx.clearRect(0, 0, 80, 80);
        ctx.save();
        ctx.translate(40, 40);
        
        // Draw orbit path
        ctx.strokeStyle = "rgba(128,128,128,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, circle.r * 0.4, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw moving point and connecting line
        const x = circle.r * 0.4 * Math.cos(circle.f * t + circle.p);
        const y = circle.r * 0.4 * Math.sin(circle.f * t + circle.p);
        
        // Draw connecting line
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // Draw moving point
        ctx.fillStyle = circle.color;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        t += 0.1;
        animation = requestAnimationFrame(animate);
      };
      animate();
    };

    slot.addEventListener("dragover", e => {
        e.preventDefault();
        slot.classList.add("dragover");
    });
    
    slot.addEventListener("dragleave", () => {
        slot.classList.remove("dragover");
    });
    
    slot.addEventListener("drop", e => {
      e.preventDefault();
      slot.classList.remove("dragover");
      const id = e.dataTransfer.getData("id");
      slot.dataset.id = id;
      slot.classList.add("filled");
      slot.style.border = "2px solid #fff";
      
      const circle = circles.find(c => c.id === id);
      if (circle) startAnimation(circle);
    });
    
    slotContainer.appendChild(slot);
  }
  
  // Add Check button container
  const buttonContainer = document.createElement("div");
  buttonContainer.id = "buttonContainer";
  buttonContainer.style.cssText = "display: flex; justify-content: center; margin: 10px; width: 100%;";
  
  const checkBtn = document.createElement("button");
  checkBtn.id = "checkBtn";
  checkBtn.innerText = "Check Solution";
  checkBtn.style.cssText = "padding: 10px 20px; background: #0ff; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px; touch-action: manipulation;";
  
  // Add both click and touch events for mobile compatibility
  checkBtn.addEventListener("click", checkAttempt);
  checkBtn.addEventListener("touchend", (e) => {
    e.preventDefault();
    checkAttempt();
  });
  
  buttonContainer.appendChild(checkBtn);
  
  slotContainer.appendChild(buttonContainer);

  showMessage(`Level: ${L.name}`);
}

// ---------------- PRECOMPUTE TARGET PATH ----------------
function computeTarget(target) {
  targetPoints = [];
  for (let step = 0; step < 300; step++) {
    let tt = (step / 300) * Math.PI * 2;
    let pos = { x: 0, y: 0 };
    target.forEach(c => {
      pos.x += c.r * Math.cos(c.f * tt + c.p);
      pos.y += c.r * Math.sin(c.f * tt + c.p);
    });
    targetPoints.push(pos);
  }
}

// ---------------- CHECK VICTORY ----------------
function checkAttempt() {
  const activeSlots = Array.from(slotContainer.querySelectorAll(".slot"));
  const activeIDs = activeSlots.map(s => s.dataset.id).filter(id => id); // Get filled slots
  
  const targetCount = levels[currentLevel].target.length;
  if (activeIDs.length !== targetCount) {
    showMessage(`Fill all ${targetCount} slots to check your solution`);
    return;
  }

  // Start drawing the pattern
  startDrawing();

  const targetIDs = levels[currentLevel].target.map(c => c.id);
  let correctPosition = 0;
  let correctCircles = 0;
  
  // Check correct positions first
  activeIDs.forEach((id, i) => {
    if (id === targetIDs[i]) {
      correctPosition++;
    }
  });
  
  // Check correct circles (including those in wrong positions)
  const remainingTarget = [...targetIDs];
  const remainingActive = [...activeIDs];
  
  activeIDs.forEach((id, i) => {
    if (id === targetIDs[i]) {
      // Remove matches we already counted
      remainingTarget.splice(remainingTarget.indexOf(id), 1);
      remainingActive.splice(remainingActive.indexOf(id), 1);
    }
  });
  
  // Check remaining for correct circles in wrong positions
  remainingActive.forEach(id => {
    const targetIndex = remainingTarget.indexOf(id);
    if (targetIndex !== -1) {
      correctCircles++;
      remainingTarget.splice(targetIndex, 1);
    }
  });

  // Record the attempt
  const attempt = {
    circles: activeIDs.map(id => circles.find(c => c.id === id)),
    feedback: {
      correctPosition,
      correctCircles,
      wrong: targetCount - correctPosition - correctCircles
    }
  };
  attempts.push(attempt);

  // Create attempt display
  const historyDiv = document.getElementById('attemptsHistory');
  const attemptDiv = document.createElement('div');
  attemptDiv.className = 'attempt';

  // Add circles
  const circlesDiv = document.createElement('div');
  circlesDiv.className = 'attempt-circles';
  attempt.circles.forEach(circle => {
    const circleDiv = document.createElement('div');
    circleDiv.className = 'attempt-circle';
    circleDiv.style.background = circle.color;
    circlesDiv.appendChild(circleDiv);
  });
  attemptDiv.appendChild(circlesDiv);

  // Add feedback dots
  const feedbackDiv = document.createElement('div');
  feedbackDiv.className = 'feedback-dots';
  
  // Correct position dots
  for (let i = 0; i < attempt.feedback.correctPosition; i++) {
    const dot = document.createElement('div');
    dot.className = 'feedback-dot correct-place';
    feedbackDiv.appendChild(dot);
  }
  
  // Correct circle wrong position dots
  for (let i = 0; i < attempt.feedback.correctCircles; i++) {
    const dot = document.createElement('div');
    dot.className = 'feedback-dot correct-wrong-place';
    feedbackDiv.appendChild(dot);
  }
  
  // Wrong dots
  for (let i = 0; i < attempt.feedback.wrong; i++) {
    const dot = document.createElement('div');
    dot.className = 'feedback-dot wrong';
    feedbackDiv.appendChild(dot);
  }
  
  attemptDiv.appendChild(feedbackDiv);
  historyDiv.insertBefore(attemptDiv, historyDiv.firstChild);

  showMessage(`Attempt ${attempts.length}: ${correctPosition} correct, ${correctCircles} misplaced`);
  
  if (correctPosition === targetCount) {
    triggerVictory();
  }

  // Handle incorrect solution
  if (correctPosition !== targetCount) {
    // Replace check button with try again button
    const buttonContainer = document.getElementById('buttonContainer');
    const checkBtn = document.getElementById('checkBtn');
    if (buttonContainer && checkBtn) {
      const tryAgainBtn = document.createElement("button");
      tryAgainBtn.id = "tryAgainBtn";
      tryAgainBtn.innerText = "Try Again";
      tryAgainBtn.style.cssText = "padding: 10px 20px; background: #f44; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px;";
      
      const handleTryAgain = () => {
        // Clear slots
        activeSlots.forEach(slot => {
          // Clear the slot completely
          slot.innerHTML = '';
          slot.classList.remove('filled');
          slot.classList.remove('locked');
          slot.style.border = '2px dashed #555';
          
          // Restore placeholder
          const placeholder = document.createElement("div");
          placeholder.className = "placeholder";
          placeholder.innerText = "drop";
          slot.appendChild(placeholder);
        });
        
        // Stop drawing epicycles
        stopDrawing();
        
        // Replace try again button with check button
        const newCheckBtn = document.createElement("button");
        newCheckBtn.id = "checkBtn";
        newCheckBtn.innerText = "Check Solution";
        newCheckBtn.style.cssText = "padding: 10px 20px; background: #0ff; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px; touch-action: manipulation;";
        
        // Add both click and touch events for mobile compatibility
        newCheckBtn.addEventListener("click", checkAttempt);
        newCheckBtn.addEventListener("touchend", (e) => {
          e.preventDefault();
          checkAttempt();
        });
        
        buttonContainer.replaceChild(newCheckBtn, tryAgainBtn);
      };
      
      tryAgainBtn.addEventListener("click", handleTryAgain);
      tryAgainBtn.addEventListener("touchend", (e) => {
        e.preventDefault();
        handleTryAgain();
      });
      
      // Animate button transition
      checkBtn.style.transition = "opacity 0.3s";
      checkBtn.style.opacity = "0";
      setTimeout(() => {
        buttonContainer.replaceChild(tryAgainBtn, checkBtn);
      }, 300);
      
      // Lock all slots
      document.querySelectorAll('.slot').forEach(slot => {
        slot.classList.add('locked');
      });
    }
  }
}

// ---------------- VICTORY ACTION ----------------
function triggerVictory() {
  showMessage("ðŸŽ‰ Correct!");
  
  // Replace check button with next button
  const buttonContainer = document.getElementById('buttonContainer');
  const checkBtn = document.getElementById('checkBtn');
  if (buttonContainer && checkBtn) {
    const nextBtn = document.createElement("button");
    nextBtn.innerText = "Next Level";
    nextBtn.style.cssText = "padding: 10px 20px; background: #0f0; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px;";
    const handleNextLevel = () => {
      currentLevel++;
      if (currentLevel >= levels.length) currentLevel = 0;
      loadLevel(currentLevel);
    };
    
    nextBtn.addEventListener("click", handleNextLevel);
    nextBtn.addEventListener("touchend", (e) => {
      e.preventDefault();
      handleNextLevel();
    });
    
    // Animate button transition
    checkBtn.style.transition = "opacity 0.3s";
    checkBtn.style.opacity = "0";
    setTimeout(() => {
      buttonContainer.replaceChild(nextBtn, checkBtn);
    }, 300);
  }
  
  solveBtn.style.display = "none"; // Hide solve when already solved
  glowTimer = 120; // âœ… Canvas glow for 2s
}

// ---------------- NEXT LEVEL ----------------
nextBtn.addEventListener("click", () => {
  currentLevel++;
  if (currentLevel >= levels.length) currentLevel = 0;
  loadLevel(currentLevel);
});

// ---------------- SHOW SOLUTION ----------------
solveBtn.addEventListener("click", () => {
  const target = levels[currentLevel].target;
  const slots = slotContainer.querySelectorAll(".slot");
  slots.forEach((s, i) => {
    s.dataset.id = target[i].id;
    s.innerText = target[i].id;
    s.style.border = "2px solid #fff";
  });
  triggerVictory(); // âœ… Auto win when showing solution
});

// ---------------- MESSAGE UI ----------------
function showMessage(txt) {
  message.innerText = txt;
  message.style.opacity = txt ? 1 : 0;
}

// ---------------- DRAW LOOP ----------------
function drawTargetShape() {
  ctx.clearRect(0, 0, 400, 400);
  ctx.save();
  ctx.translate(200, 200);

  // Target outline
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(targetPoints[0].x, targetPoints[0].y);
  targetPoints.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.stroke();

  ctx.restore();
}

function draw() {
  if (!isDrawing) {
    drawTargetShape();
    return;
  }

  ctx.clearRect(0, 0, 400, 400);
  ctx.save();
  ctx.translate(200, 200);

  // Target outline
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(targetPoints[0].x, targetPoints[0].y);
  targetPoints.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.stroke();

  // Draw active epicycles
  const active = [];
  slotContainer.querySelectorAll(".slot").forEach(s => {
    if (s.dataset.id) {
      const c = circles.find(cc => cc.id === s.dataset.id);
      if (c) active.push(c);
    }
  });

  let pos = { x: 0, y: 0 };
  active.forEach(c => {
    // Draw orbit path
    ctx.strokeStyle = "rgba(128,128,128,0.2)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, c.r, 0, Math.PI * 2);
    ctx.stroke();

    const next = { x: pos.x + c.r * Math.cos(c.f * t + c.p),
                   y: pos.y + c.r * Math.sin(c.f * t + c.p) };
    
    // Draw connecting line
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineTo(next.x, next.y);
    ctx.stroke();

    // Draw moving point
    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.arc(next.x, next.y, 3, 0, Math.PI * 2);
    ctx.fill();

    pos = next;
  });

  ctx.restore();
  t += 0.01;

  // âœ… Victory Glow
  if (glowTimer > 0) {
    canvas.style.boxShadow = "0 0 20px 5px #0f0";
    glowTimer--;
    if (glowTimer === 0) canvas.style.boxShadow = "none";
  }

  drawAnimationId = requestAnimationFrame(draw);
}

// ---------------- START ----------------
let isDrawing = false;
let drawAnimationId = null;

function startDrawing() {
  if (!isDrawing) {
    isDrawing = true;
    draw();
  }
}

function stopDrawing() {
  isDrawing = false;
  if (drawAnimationId) {
    cancelAnimationFrame(drawAnimationId);
    drawAnimationId = null;
  }
  // Draw just the target shape
  drawTargetShape();
}

loadLevel(0);
draw(); // Start the animation loop (will only show target shape until check)
</script>
</body>
</html>