<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yay! Yay! Yay! Yay!</title>
    <script>
        // Audio context and oscillator management
        let audioContext;
        let oscillators = new Map(); // Map of circle ID to oscillator
        let gainNodes = new Map();   // Map of circle ID to gain node
        let pannerNodes = new Map(); // Map of circle ID to panner node
        let drumSamples = new Map(); // Map of circle ID to assigned drum sample
        let audioBuffers = []; // Array to store loaded audio buffers
        let lastDrumTime = new Map(); // Track last drum hit time to prevent spam
        window.audioEnabled = true;  // Global audio state
        
        // Load drum samples
        async function loadDrumSamples() {
            if (!audioContext) return;
            
            const sampleFiles = ['1.wav', '2.wav', '3.wav', '4.wav', '5.wav'];
            
            for (let i = 0; i < sampleFiles.length; i++) {
                try {
                    const response = await fetch(sampleFiles[i]);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    audioBuffers[i] = audioBuffer;
                    console.log(`Loaded drum sample ${i + 1}`);
                } catch (error) {
                    console.error(`Failed to load drum sample ${i + 1}:`, error);
                }
            }
        }
        
        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio context created, state:', audioContext.state);
                // Resume audio context if it's suspended (required for autoplay policies)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                    });
                }
                // Load drum samples after context is created
                loadDrumSamples();
            }
        }
        
        // Create or update oscillator for a circle
        function updateCircleAudio(circle, isActive = true) {
            if (!window.audioEnabled) return;
            
            // Initialize audio context if needed
            initAudio();
            
            if (!audioContext) return;
            
            const circleId = circle.id;
            
            // Remove existing audio if circle is no longer active
            if (!isActive) {
                if (oscillators.has(circleId)) {
                    const oscillator = oscillators.get(circleId);
                    const gainNode = gainNodes.get(circleId);
                    
                    if (gainNode) {
                        // Fade out over 0.5 seconds
                        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
                        setTimeout(() => {
                            oscillator.stop();
                            oscillators.delete(circleId);
                            gainNodes.delete(circleId);
                            pannerNodes.delete(circleId);
                        }, 500);
                    } else {
                        oscillator.stop();
                        oscillators.delete(circleId);
                        gainNodes.delete(circleId);
                        pannerNodes.delete(circleId);
                    }
                }
                return;
            }
            
            // Create oscillator if it doesn't exist
            if (!oscillators.has(circleId)) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const pannerNode = audioContext.createStereoPanner();
                
                // Create a compressor to prevent clipping
                const compressor = audioContext.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
                compressor.knee.setValueAtTime(30, audioContext.currentTime);
                compressor.ratio.setValueAtTime(12, audioContext.currentTime);
                compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
                compressor.release.setValueAtTime(0.25, audioContext.currentTime);
                
                // Connect the audio chain
                oscillator.connect(gainNode);
                gainNode.connect(pannerNode);
                pannerNode.connect(compressor);
                compressor.connect(audioContext.destination);
                
                // Store references
                oscillators.set(circleId, oscillator);
                gainNodes.set(circleId, gainNode);
                pannerNodes.set(circleId, pannerNode);
                
                // Start the oscillator
                oscillator.start();
            }
            
            // Update parameters based on circle properties
            const oscillator = oscillators.get(circleId);
            const gainNode = gainNodes.get(circleId);
            const pannerNode = pannerNodes.get(circleId);
            
            // Frequency mapping: baseNote + f*50 Hz (with range limiting)
            const baseNote = 220; // A3
            const frequency = Math.max(20, Math.min(2000, baseNote + circle.f * 50)); // Clamp to 20-2000 Hz
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // Remove panning - set to center
            pannerNode.pan.setValueAtTime(0, audioContext.currentTime);
            
            // Use sine wave for smooth, Glass-like tones
            oscillator.type = 'sine';
            
            // Debug logging
            console.log(`Audio updated for circle ${circleId}: freq=${frequency}Hz, pan=${pan}`);
        }
        
        // Create a drum sound for a circle
        function createDrumSound(circleId, frequency) {
            if (!audioContext || !window.audioEnabled) return;
            
            // Prevent drum spam - only trigger once per 0.3 seconds
            const now = audioContext.currentTime;
            const lastHit = lastDrumTime.get(circleId) || 0;
            if (now - lastHit < 0.3) return;
            lastDrumTime.set(circleId, now);
            
            // Get the assigned drum sample for this circle
            let sampleIndex = drumSamples.get(circleId);
            if (sampleIndex === undefined) {
                // Assign a random sample if none assigned yet
                sampleIndex = Math.floor(Math.random() * 5);
                drumSamples.set(circleId, sampleIndex);
            }
            
            // Check if we have the sample loaded
            if (!audioBuffers[sampleIndex]) return;
            
            // Create audio buffer source for the drum sample
            const drumSource = audioContext.createBufferSource();
            const drumGain = audioContext.createGain();
            
            // Connect drum audio chain
            drumSource.connect(drumGain);
            drumGain.connect(audioContext.destination);
            
            // Set the buffer to the loaded sample
            drumSource.buffer = audioBuffers[sampleIndex];
            
            // Adjust playback rate based on frequency (optional)
            const playbackRate = 1.0 + (Math.abs(frequency) - 1) * 0.1; // Slight variation
            drumSource.playbackRate.setValueAtTime(playbackRate, now);
            
            // Set volume
            drumGain.gain.setValueAtTime(0.4, now);
            
            // Start the drum sample
            drumSource.start(now);
        }
        
        // Update audio volume based on Y position (called from animation loop)
        function updateCircleVolume(circleId, yPosition) {
            if (!window.audioEnabled || !gainNodes.has(circleId)) return;
            
            const gainNode = gainNodes.get(circleId);
            const circle = circles.find(c => c.id === circleId);
            if (!circle) return;
            
            // Map Y position to radius scaling: Y position as percentage of canvas height
            // For game slots, canvas height is 80, so Y ranges from -40 to +40
            const canvasHeight = 80;
            const yPercentage = Math.max(0, Math.min(1, (yPosition + 40) / canvasHeight)); // 0 to 1
            
            // Scale the radius by the Y percentage
            const scaledRadius = circle.r * yPercentage;
            const dynamicVolume = Math.max(0, Math.min(0.3, scaledRadius / 100 * 0.3)); // Clamp to 0-0.3
            
            // Smooth volume change with exponential smoothing to prevent popping
            const currentGain = gainNode.gain.value;
            const smoothedGain = currentGain * 0.9 + dynamicVolume * 0.1; // Smoothing factor
            
            gainNode.gain.setValueAtTime(smoothedGain, audioContext.currentTime);
            
            // Check if circle is in upright position and trigger drum
            const isUpright = yPosition < -30; // Threshold for upright position in game
            if (isUpright) {
                createDrumSound(circleId, circle.f);
            }
        }
        
        // Update audio for all active circles
        function updateAllAudio(activeCircles) {
            if (!window.audioEnabled) return;
            
            console.log('Updating audio for', activeCircles.length, 'circles');
            
            // Stop audio for all circles first
            oscillators.forEach((osc, id) => {
                osc.stop();
            });
            oscillators.clear();
            gainNodes.clear();
            pannerNodes.clear();
            
            // Start audio for active circles
            activeCircles.forEach(circle => {
                updateCircleAudio(circle, true);
            });
        }
        
        // Stop all audio with fade out
        function stopAllAudio() {
            const fadeOutTime = 0.5; // 0.5 second fade out
            
            oscillators.forEach((osc, id) => {
                const gainNode = gainNodes.get(id);
                if (gainNode) {
                    // Fade out the gain
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + fadeOutTime);
                    // Stop the oscillator after fade out
                    setTimeout(() => {
                        if (osc) {
                            osc.stop();
                        }
                    }, fadeOutTime * 1000);
                } else {
                    osc.stop();
                }
            });
            
            // Clear references after fade out
            setTimeout(() => {
                oscillators.clear();
                gainNodes.clear();
                pannerNodes.clear();
                drumSamples.clear();
                lastDrumTime.clear();
            }, fadeOutTime * 1000);
        }
    </script>
    <style>
        body { 
            background:#111; 
            color:#fff; 
            font-family:sans-serif; 
            display:flex; 
            flex-direction:column; 
            align-items:center;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 { 
            font-size: clamp(24px, 5vw, 32px);
            margin: 10px 0;
            text-align: center;
        }
        h2 {
            font-size: clamp(18px, 4vw, 24px);
            margin: 5px 0 15px 0;
            text-align: center;
        }
        #container { 
            display: flex; 
            gap: 20px; 
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 800px;
        }
        .circleBox, .slots { 
            background: #222; 
            padding: 10px; 
            border-radius: 8px; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 10px; 
            width: min(250px, calc(100% - 20px));
            min-height: 60px;
            justify-content: center;
            align-content: flex-start;
        }
        .circle { 
            cursor: grab; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            position: relative;
            width: 80px;
            height: 80px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 5px;
            border: 1px solid #333;
        }
        .circle canvas {
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            background: transparent;
        }
        .circle.dragging { 
            opacity: 0.9; 
            position: fixed; 
            pointer-events: none; 
            z-index: 1000; 
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .slot { 
            width: 80px; 
            height: 80px; 
            border: 2px dashed #555; 
            border-radius: 8px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: #888; 
            font-size: 12px;
            background: #1a1a1a;
            padding: 0;
            position: relative;
            overflow: hidden;
        }
        .slot canvas {
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            display: none;
        }
        .slot.filled canvas {
            display: block;
        }
        .slot.filled .placeholder {
            display: none;
        }
        .slot .placeholder {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }
        .slot.dragover:not(.locked) { 
            border-color: #fff; 
            background: rgba(255,255,255,0.1);
        }
        .slot.locked {
            pointer-events: none;
            opacity: 0.8;
        }
        canvas { 
            background: #000; 
            border: 4px solid #444; 
            margin: 20px 0;
            transition: border 0.3s, box-shadow 0.3s;
            max-width: 100%;
            height: auto;
        }
        #message { 
            font-size: clamp(18px, 4vw, 24px);
            margin: 10px; 
            opacity: 0; 
            transition: opacity 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            white-space: pre-line;
        }
        #nextBtn, #solveBtn { 
            padding: 10px 20px; 
            background: #0ff; 
            color: #000; 
            border: none; 
            border-radius: 6px; 
            font-size: clamp(16px, 3vw, 18px);
            cursor: pointer; 
            margin: 5px;
            display: none;
            min-width: 120px;
        }
        #nextBtn:hover, #solveBtn:hover { 
            background: #7ff;
        }
        #historyPanel {
            background: #222;
            border-radius: 8px;
            /* padding: 15px; */
            margin: 20px auto;
            width: 100%;
            max-width: 800px;
        }

        .attempt {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid #444;
            animation: fadeIn 0.3s ease-out;
        }

        .attempt:last-child {
            border-bottom: none;
        }

        .attempt-circles {
            display: flex;
            gap: 5px;
        }

        .attempt-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid #0008;
        }

        .feedback-dots {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }

        .feedback-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid #fff4;
        }

        .feedback-dot.correct-place {
            background: #0f0;
        }

        .feedback-dot.correct-wrong-place {
            background: #ff0;
        }

        .feedback-dot.wrong {
            background: #444;
        }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            padding: 10px;
            border-bottom: 1px solid #444;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.5s ease-out;
        }
        
        .victory-modal {
            background: #222;
            border: 3px solid #0ff;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            margin: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            animation: fadeIn 0.5s ease-out;
        }
        
        .victory-title {
            font-size: clamp(24px, 5vw, 32px);
            margin-bottom: 20px;
            background: linear-gradient(45deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
        }
        
        .victory-message {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 30px;
            color: #fff;
            line-height: 1.4;
        }
        
        .victory-btn {
            padding: 15px 30px;
            background: linear-gradient(45deg, #0ff, #f0f);
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .victory-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }

        @media (max-width: 600px) {
            #container {
                gap: 10px;
            }
            .circleBox, .slots {
                width: 100%;
                max-width: none;
            }
            .circle {
                width: 40px;
                height: 40px;
            }
            .circle canvas {
                width: 40px;
                height: 40px;
            }
            .slot {
                width: 40px;
                height: 40px;
            }
            .slot canvas {
                width: 40px;
                height: 40px;
            }
            canvas {
                width: 100%;
                max-height: 50vh;
            }
            .attempt {
                flex-wrap: wrap;
            }
            .feedback-dots {
                margin-left: 0;
                margin-top: 5px;
            }
            .attempt-circle {
                width: 15px;
                height: 15px;
            }
            .feedback-dot {
                width: 8px;
                height: 8px;
            }
        }
    </style>
</head>
<body>
<div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 800px; margin-bottom: 20px;">
  <a href="index.html">
    <img src="logo_sub.png" alt="Yay! Yay! Yay! Yay!" style="width: 100%;">
  </a>
</div>

<div id="container">
  <div class="circleBox" id="circleBox"></div>
  <div class="slots" id="slots"></div>
</div>

<canvas id="canvas" width="400" height="350"></canvas>

<div id="historyPanel">
  <div class="legend">
    <div class="legend-item">
      <div class="feedback-dot correct-place"></div>
      <span>Correct circle</span>
    </div>
    <div class="legend-item">
      <div class="feedback-dot wrong"></div>
      <span>Wrong circle</span>
    </div>
  </div>
  <div id="attemptsHistory"></div>
</div>

<div id="message">Correct!</div>
<div>
  <button id="nextBtn">Next Level</button>
  <button id="solveBtn">Show Solution</button>
</div>

<script>
    //--------- LEVEL DATA
const levels = [
  {
    "name": "Ellipse",
    "target": [
      { "id": "c1", "color": "#FFEB3B", "r": 80, "f": 1, "p": 0 },
      { "id": "c2", "color": "#FF3BE7", "r": 40, "f": -1, "p": 1.2 }
    ],
    "decoys": [
      { "id": "d1", "color": "#00E5FF", "r": 60, "f": 3, "p": 0.8 },
      { "id": "d2", "color": "#7C4DFF", "r": 30, "f": 2, "p": 1.57 }
    ]
  },
  {
    "name": "Figure Eight",
    "target": [
      { "id": "c1", "color": "#FF9100", "r": 70, "f": 1, "p": 0 },
      { "id": "c2", "color": "#B0BEC5", "r": 30, "f": 2, "p": 1.57 }
    ],
    "decoys": [
      { "id": "d1", "color": "#C158DC", "r": 40, "f": -3, "p": 1.3 },
      { "id": "d2", "color": "#1A237E", "r": 40, "f": 3, "p": 1.2 }
    ]
  },
  {
    "name": "Trefoil Knot",
    "target": [
      { "id": "c1", "color": "#FFEB3B", "r": 70, "f": 1, "p": 0 },
      { "id": "c2", "color": "#FF3BE7", "r": 40, "f": 3, "p": 1.2 },
      { "id": "c3", "color": "#00E5FF", "r": 20, "f": -2, "p": 0.6 }
    ],
    "decoys": [
      { "id": "d1", "color": "#7C4DFF", "r": 50, "f": -4, "p": 2.0 },
      { "id": "d2", "color": "##FF9100", "r": 15, "f": 3, "p": 0.5 }
    ]
  },
  {
    "name": "Heart",
    "target": [
      { "id": "c1", "color": "#B0BEC5", "r": 60, "f": 1, "p": 0 },
      { "id": "c2", "color": "#C158DC", "r": 30, "f": -2, "p": 1.2 },
      { "id": "c3", "color": "#1A237E", "r": 15, "f": 3, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d1", "color": "#FFEB3B", "r": 40, "f": -3, "p": 1.0 },
      { "id": "d2", "color": "#FF3BE7", "r": 30, "f": -4, "p": 1.5 }
    ]
  },
  {
    "name": "Star (5-point)",
    "target": [
      { "id": "c1", "color": "#00E5FF", "r": 70, "f": 5, "p": 0 },
      { "id": "c2", "color": "#7C4DFF", "r": 30, "f": -4, "p": 1.5 }
    ],
    "decoys": [
      { "id": "d1", "color": "#FF9100", "r": 50, "f": 2, "p": 0.7 },
      { "id": "d2", "color": "#B0BEC5", "r": 20, "f": -2, "p": 1.2 }
    ]
  },
  {
    "name": "Clover (3 leaves)",
    "target": [
      { "id": "c1", "color": "#C158DC", "r": 50, "f": 3, "p": 0 },
      { "id": "c2", "color": "#1A237E", "r": 20, "f": -2, "p": 1.2 }
    ],
    "decoys": [
      { "id": "d1", "color": "#FFEB3B", "r": 35, "f": 4, "p": 0.9 },
      { "id": "d2", "color": "#FF3BE7", "r": 40, "f": 3, "p": 1.57 }
    ]
  },
  {
    "name": "Lissajous Curve",
    "target": [
      { "id": "c1", "color": "#00E5FF", "r": 60, "f": 2, "p": 0 },
      { "id": "c2", "color": "#7C4DFF", "r": 40, "f": 3, "p": 1.57 }
    ],
    "decoys": [
      { "id": "d1", "color": "#FF9100", "r": 50, "f": -1, "p": 0.8 },
      { "id": "d2", "color": "#B0BEC5", "r": 30, "f": 2, "p": 1.5 }
    ]
  },
  {
    "name": "Infinity Symbol",
    "target": [
      { "id": "c1", "color": "#C158DC", "r": 70, "f": 1, "p": 0 },
      { "id": "c2", "color": "#1A237E", "r": 30, "f": 2, "p": 1.5 }
    ],
    "decoys": [
      { "id": "d1", "color": "#FFEB3B", "r": 40, "f": -3, "p": 1.2 },
      { "id": "d2", "color": "#FF3BE7", "r": 15, "f": 4, "p": 1.0 }
    ]
  },
  {
    "name": "Waveform (Sine Stack)",
    "target": [
      { "id": "c26", "color": "#00E5FF", "r": 50, "f": 1, "p": 0 },
      { "id": "c27", "color": "#7C4DFF", "r": 30, "f": 2, "p": 0.5 },
      { "id": "c28", "color": "#FF9100", "r": 15, "f": 4, "p": 1.0 }
    ],
    "decoys": [
      { "id": "d1", "color": "#B0BEC5", "r": 45, "f": -3, "p": 2.0 },
      { "id": "d2", "color": "#C158DC", "r": 10, "f": 7, "p": 0.5 }
    ]
  },
  {
    "name": "Complex Flower",
    "target": [
      { "id": "c40", "color": "#1A237E", "r": 60, "f": 3, "p": 0 },
      { "id": "c41", "color": "#FFEB3B", "r": 30, "f": 5, "p": 1.0 },
      { "id": "c42", "color": "#FF3BE7", "r": 20, "f": -4, "p": 2.1 },
      { "id": "c43", "color": "#00E5FF", "r": 10, "f": 7, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d40", "color": "#7C4DFF", "r": 25, "f": -5, "p": 1.3 },
      { "id": "c51", "color": "#FF9100", "r": 15, "f": -5, "p": 0.8 }
    ]
  },
  {
    "name": "Celtic Knot",
    "target": [
      { "id": "c48", "color": "#B0BEC5", "r": 50, "f": 2, "p": 0 },
      { "id": "c49", "color": "#C158DC", "r": 35, "f": -3, "p": 1.7 },
      { "id": "c50", "color": "#1A237E", "r": 25, "f": 4, "p": 3.1 },
      { "id": "c51", "color": "#FFEB3B", "r": 15, "f": -5, "p": 0.8 }
    ],
    "decoys": [
      { "id": "d42", "color": "#FF3BE7", "r": 40, "f": 2, "p": 2.0 },
      { "id": "c55", "color": "#00E5FF", "r": 15, "f": -4, "p": 0.5 }
    ]
  },
  {
    "name": "Orbit Rings",
    "target": [
      { "id": "c52", "color": "#7C4DFF", "r": 70, "f": 1, "p": 0 },
      { "id": "c53", "color": "#FF9100", "r": 50, "f": -2, "p": 1.3 },
      { "id": "c54", "color": "#B0BEC5", "r": 30, "f": 3, "p": 2.2 },
      { "id": "c55", "color": "#C158DC", "r": 15, "f": -4, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d43", "color": "#1A237E", "r": 20, "f": -3, "p": 1.0 },
      { "id": "c59", "color": "#FFEB3B", "r": 10, "f": -6, "p": 0.7 }
    ]
  },
  {
    "name": "Four Leaf Clover",
    "target": [
      { "id": "c56", "color": "#FF3BE7", "r": 50, "f": 4, "p": 0 },
      { "id": "c57", "color": "#00E5FF", "r": 30, "f": -3, "p": 1.2 },
      { "id": "c58", "color": "#7C4DFF", "r": 20, "f": 5, "p": 2.5 },
      { "id": "c59", "color": "#FF9100", "r": 10, "f": -6, "p": 0.7 }
    ],
    "decoys": [
      { "id": "d44", "color": "#B0BEC5", "r": 25, "f": 3, "p": 2.1 },
      { "id": "c63", "color": "#C158DC", "r": 15, "f": -4, "p": 0.4 }
    ]
  },
  {
    "name": "Chaos Star",
    "target": [
      { "id": "c60", "color": "#1A237E", "r": 60, "f": 7, "p": 0 },
      { "id": "c61", "color": "#FFEB3B", "r": 30, "f": -6, "p": 1.1 },
      { "id": "c62", "color": "#FF3BE7", "r": 20, "f": 5, "p": 2.8 },
      { "id": "c63", "color": "#00E5FF", "r": 15, "f": -4, "p": 0.4 }
    ],
    "decoys": [
      { "id": "d45", "color": "#7C4DFF", "r": 25, "f": 2, "p": 1.3 },
      { "id": "c67", "color": "#FF9100", "r": 10, "f": 4, "p": 0.9 }
    ]
  },
  {
    "name": "Wave Interference",
    "target": [
      { "id": "c64", "color": "#B0BEC5", "r": 55, "f": 1, "p": 0 },
      { "id": "c65", "color": "#C158DC", "r": 35, "f": 2, "p": 1.7 },
      { "id": "c66", "color": "#1A237E", "r": 25, "f": -3, "p": 2.9 },
      { "id": "c67", "color": "#FFEB3B", "r": 10, "f": 4, "p": 0.9 }
    ],
    "decoys": [
      { "id": "d46", "color": "#FF3BE7", "r": 20, "f": -5, "p": 0.6 },
      { "id": "c71", "color": "#00E5FF", "r": 10, "f": -5, "p": 0.3 }
    ]
  },
  {
    "name": "Radiant Sun",
    "target": [
      { "id": "c68", "color": "#7C4DFF", "r": 70, "f": 8, "p": 0 },
      { "id": "c69", "color": "#FF9100", "r": 40, "f": -7, "p": 1.4 },
      { "id": "c70", "color": "#B0BEC5", "r": 20, "f": 6, "p": 2.3 },
      { "id": "c71", "color": "#C158DC", "r": 10, "f": -5, "p": 0.3 }
    ],
    "decoys": [
      { "id": "d47", "color": "#1A237E", "r": 25, "f": 3, "p": 2.0 },
      { "id": "c75", "color": "#FFEB3B", "r": 10, "f": -5, "p": 0.8 }
    ]
  },
  {
    "name": "Entangled Loops",
    "target": [
      { "id": "c72", "color": "#FF3BE7", "r": 65, "f": 2, "p": 0 },
      { "id": "c73", "color": "#00E5FF", "r": 40, "f": -3, "p": 1.6 },
      { "id": "c74", "color": "#7C4DFF", "r": 20, "f": 4, "p": 2.7 },
      { "id": "c75", "color": "#FF9100", "r": 10, "f": -5, "p": 0.8 }
    ],
    "decoys": [
      { "id": "d48", "color": "#B0BEC5", "r": 30, "f": 3, "p": 1.2 },
      { "id": "c79", "color": "#C158DC", "r": 10, "f": 4, "p": 0.5 }
    ]
  },
  {
    "name": "Quad Infinity",
    "target": [
      { "id": "c76", "color": "#1A237E", "r": 60, "f": 1, "p": 0 },
      { "id": "c77", "color": "#FFEB3B", "r": 40, "f": 2, "p": 1.3 },
      { "id": "c78", "color": "#FF3BE7", "r": 20, "f": -3, "p": 2.5 },
      { "id": "c79", "color": "#00E5FF", "r": 10, "f": 4, "p": 0.5 }
    ],
    "decoys": [
      { "id": "d49", "color": "#7C4DFF", "r": 25, "f": -2, "p": 1.5 },
      { "id": "c75", "color": "#FF9100", "r": 10, "f": -5, "p": 0.8 }
    ]
  }
];

let currentLevel = 0;
let circles = [];
let targetPoints = [];
let t = 0;
let glowTimer = 0;
let attempts = [];

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const box = document.getElementById("circleBox");
const slotContainer = document.getElementById("slots");
const message = document.getElementById("message");
const nextBtn = document.getElementById("nextBtn");
const solveBtn = document.getElementById("solveBtn");

//----- LOAD LEVEL
function loadLevel(n) {
  const L = levels[n];
  
  // Compute target points first
  computeTarget(L.target);
  
  // Clear all animations first
  const allCanvases = document.querySelectorAll('.circle canvas, .slot canvas');
  allCanvases.forEach(canvas => {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });

  box.innerHTML = "";
  slotContainer.innerHTML = "";
  nextBtn.style.display = "none";
  solveBtn.style.display = "none"; // Hide solve button initially
  canvas.style.boxShadow = "none";
  document.getElementById('attemptsHistory').innerHTML = "";
  attempts = [];
  
  // Stop main canvas drawing (and show target shape)
  stopDrawing();
  
  // Stop all audio when loading new level
  stopAllAudio();

  // Use exactly the number of target circles needed for this level
  const targetCircles = L.target;
  
  // Use exactly 2 decoys
  const decoyCircles = L.decoys.slice(0, 2);

  // Merge target + decoys and shuffle
  circles = [...targetCircles, ...decoyCircles].sort(() => Math.random() - 0.5);

  // Create draggable circles with animated previews
  circles.forEach(c => {
    const div = document.createElement("div");
    div.className = "circle";
    div.draggable = true;
    div.dataset.id = c.id;
    
    // Create preview canvas
    const canvas = document.createElement("canvas");
    // Use smaller canvas on mobile
    const isMobile = window.innerWidth <= 600;
    canvas.width = isMobile ? 40 : 80;
    canvas.height = isMobile ? 40 : 80;
    div.appendChild(canvas);

    // Function to create animation context
    const createAnimation = (targetCanvas) => {
      const ctx = targetCanvas.getContext("2d");
      let t = 0;
      let animationId;
      const isMobile = window.innerWidth <= 600;
      const size = isMobile ? 40 : 80;
      const center = size / 2;
      const scale = isMobile ? 0.2 : 0.4; // Adjust scale for mobile
      
      // Initialize trail
      let trail = [];
      const trailLength = 30; // Shorter trail for previews
      
      const animate = () => {
        ctx.clearRect(0, 0, size, size);
        ctx.save();
        ctx.translate(center, center);
        
        // Draw orbit path
        ctx.strokeStyle = "rgba(128,128,128,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, c.r * scale, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw moving point and connecting line
        const x = c.r * scale * Math.cos(c.f * t + c.p);
        const y = c.r * scale * Math.sin(c.f * t + c.p);
        
        // Update audio volume based on Y position (for draggable previews)
        updateCircleVolume(c.id, y);
        
        // Add point to trail
        trail.push({ x, y, t });
        if (trail.length > trailLength) {
          trail.shift();
        }
        
        // Draw trail
        if (trail.length > 1) {
          ctx.strokeStyle = c.color + "60"; // More transparent for previews
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(trail[0].x, trail[0].y);
          for (let i = 1; i < trail.length; i++) {
            ctx.lineTo(trail[i].x, trail[i].y);
          }
          ctx.stroke();
        }
        
        // Draw connecting line
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // Draw moving point
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        t += 0.01;
        animationId = requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
      
      // Return function to stop animation
      return () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
      };
    };

    // Start animation for the original circle
    const stopAnimation = createAnimation(canvas);

    // Desktop drag events
    div.addEventListener("dragstart", e => {
      e.dataTransfer.setData("id", c.id);
      const clone = canvas.cloneNode(true);
      e.dataTransfer.setDragImage(clone, 40, 40);
    });

    // Cleanup when element is removed
    div.addEventListener("remove", () => {
      stopAnimation();
    });

    // Mobile touch events
    div.addEventListener("touchstart", e => {
        if (e.cancelable) e.preventDefault();
        const touch = e.touches[0];
        const clone = div.cloneNode(true);
        clone.className = "circle dragging";
        document.body.appendChild(clone);
        
        // Start animation in the clone
        const stopCloneAnimation = createAnimation(clone.querySelector('canvas'));
        
        const moveCircle = (moveEvent) => {
            if (moveEvent.cancelable) moveEvent.preventDefault();
            const moveTouch = moveEvent.touches[0];
            clone.style.left = moveTouch.pageX + "px";
            clone.style.top = moveTouch.pageY + "px";
            
            // Find slot under touch point
            const slots = document.querySelectorAll(".slot:not(.locked)");
            slots.forEach(slot => slot.classList.remove("dragover"));
            
            const touchTarget = document.elementFromPoint(moveTouch.pageX, moveTouch.pageY);
            const slot = touchTarget?.closest(".slot:not(.locked)");
            if (slot) slot.classList.add("dragover");
        };
        
        const endTouch = (endEvent) => {
            if (endEvent.cancelable) endEvent.preventDefault();
            const endTouch = endEvent.changedTouches[0];
            const dropTarget = document.elementFromPoint(endTouch.pageX, endTouch.pageY);
            const slot = dropTarget?.closest(".slot:not(.locked)");
            
            if (slot) {
                // Clear the slot completely
                slot.innerHTML = '';
                slot.classList.remove("dragover");
                slot.dataset.id = c.id;
                slot.classList.add("filled");
                
                // Create new canvas
                const canvas = document.createElement('canvas');
                const isMobile = window.innerWidth <= 600;
                canvas.width = isMobile ? 40 : 80;
                canvas.height = isMobile ? 40 : 80;
                canvas.style.cssText = "width: 100%; height: 100%; display: block;";
                slot.appendChild(canvas);
                
                // Start animation for this slot
                const ctx = canvas.getContext("2d");
                let t = 0;
                
                // Initialize trail for this slot
                slot.trail = [];
                slot.trailLength = 50; // Number of trail points to keep
                
                const animate = () => {
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.save();
                  ctx.translate(canvas.width/2, canvas.height/2);
                  
                  // Draw orbit path
                  ctx.strokeStyle = "rgba(128,128,128,0.2)";
                  ctx.lineWidth = 1;
                  ctx.beginPath();
                  ctx.arc(0, 0, c.r * 0.4, 0, Math.PI * 2);
                  ctx.stroke();
                  
                  // Draw moving point and connecting line
                  const x = c.r * 0.4 * Math.cos(c.f * t + c.p);
                  const y = c.r * 0.4 * Math.sin(c.f * t + c.p);
                  
                  // Update audio volume based on Y position
                  updateCircleVolume(c.id, y);
                  
                  // Add point to trail
                  slot.trail.push({ x, y, t });
                  if (slot.trail.length > slot.trailLength) {
                    slot.trail.shift();
                  }
                  
                  // Draw trail
                  if (slot.trail.length > 1) {
                    ctx.strokeStyle = c.color + "80"; // Semi-transparent
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(slot.trail[0].x, slot.trail[0].y);
                    for (let i = 1; i < slot.trail.length; i++) {
                      ctx.lineTo(slot.trail[i].x, slot.trail[i].y);
                    }
                    ctx.stroke();
                  }
                  
                  // Draw connecting line
                  ctx.strokeStyle = "#fff";
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.lineTo(x, y);
                  ctx.stroke();
                  
                  // Draw moving point
                  ctx.fillStyle = c.color;
                  ctx.beginPath();
                  ctx.arc(x, y, 3, 0, Math.PI * 2);
                  ctx.fill();
                  
                  ctx.restore();
                  t += 0.01;
                  slot.animationId = requestAnimationFrame(animate);
                };
                animate();
                
                slot.style.border = "2px solid #fff";
                
                // Initialize audio context and update audio
                initAudio();
                updateCircleAudio(c, true);
            }
            
            stopCloneAnimation();
            clone.remove();
            document.removeEventListener("touchmove", moveCircle);
            document.removeEventListener("touchend", endTouch);
        };
        
        document.addEventListener("touchmove", moveCircle);
        document.addEventListener("touchend", endTouch);
    });

    box.appendChild(div);
  });

  // Create slots based on target count
  const targetCount = L.target.length;
  for (let i = 0; i < targetCount; i++) {
    const slot = document.createElement("div");
    slot.className = "slot";
    
    // Add placeholder text
    const placeholder = document.createElement("div");
    placeholder.className = "placeholder";
    placeholder.innerText = "drop";
    slot.appendChild(placeholder);
    
    // Add canvas for animation
    const canvas = document.createElement("canvas");
    // Use smaller canvas on mobile
    const isMobile = window.innerWidth <= 600;
    canvas.width = isMobile ? 40 : 80;
    canvas.height = isMobile ? 40 : 80;
    slot.appendChild(canvas);
    
    slot.addEventListener("dragover", e => {
        e.preventDefault();
        slot.classList.add("dragover");
    });
    
    slot.addEventListener("dragleave", () => {
        slot.classList.remove("dragover");
    });
    
    slot.addEventListener("drop", e => {
      e.preventDefault();
      slot.classList.remove("dragover");
      const id = e.dataTransfer.getData("id");
      slot.dataset.id = id;
      slot.classList.add("filled");
      slot.style.border = "2px solid #fff";
      
      // Clear placeholder and show canvas
      const placeholder = slot.querySelector('.placeholder');
      if (placeholder) placeholder.style.display = 'none';
      
      const canvas = slot.querySelector('canvas');
      if (canvas) canvas.style.display = 'block';
      
      const circle = circles.find(c => c.id === id);
      if (circle) {
        // Start animation for this slot
        const ctx = canvas.getContext("2d");
        let t = 0;
        
        // Initialize trail for this slot
        slot.trail = [];
        slot.trailLength = 50; // Number of trail points to keep
        
        const animate = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.translate(canvas.width/2, canvas.height/2);
          
          // Draw orbit path
          ctx.strokeStyle = "rgba(128,128,128,0.2)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, circle.r * 0.4, 0, Math.PI * 2);
          ctx.stroke();
          
          // Draw moving point and connecting line
          const x = circle.r * 0.4 * Math.cos(circle.f * t + circle.p);
          const y = circle.r * 0.4 * Math.sin(circle.f * t + circle.p);
          
          // Add point to trail
          slot.trail.push({ x, y, t });
          if (slot.trail.length > slot.trailLength) {
            slot.trail.shift();
          }
          
          // Draw trail
          if (slot.trail.length > 1) {
            ctx.strokeStyle = circle.color + "80"; // Semi-transparent
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(slot.trail[0].x, slot.trail[0].y);
            for (let i = 1; i < slot.trail.length; i++) {
              ctx.lineTo(slot.trail[i].x, slot.trail[i].y);
            }
            ctx.stroke();
          }
          
          // Draw connecting line
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(x, y);
          ctx.stroke();
          
          // Draw moving point
          ctx.fillStyle = circle.color;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          t += 0.01;
          slot.animationId = requestAnimationFrame(animate);
        };
        animate();
      }
    });
    
    slotContainer.appendChild(slot);
  }
  
  // Add Check button container
  const buttonContainer = document.createElement("div");
  buttonContainer.id = "buttonContainer";
  buttonContainer.style.cssText = "display: flex; justify-content: center; margin: 10px; width: 100%;";
  
  const checkBtn = document.createElement("button");
  checkBtn.id = "checkBtn";
  checkBtn.innerText = "Check Solution";
  checkBtn.style.cssText = "padding: 10px 20px; background: #0ff; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px; touch-action: manipulation;";
  
  // Add both click and touch events for mobile compatibility
  checkBtn.addEventListener("click", checkAttempt);
  checkBtn.addEventListener("touchend", (e) => {
    e.preventDefault();
    checkAttempt();
  });
  
  buttonContainer.appendChild(checkBtn);
  
  // Add audio toggle button
  const audioToggleBtn = document.createElement("button");
  audioToggleBtn.id = "audioToggle";
  audioToggleBtn.innerText = "ðŸ”Š Audio: ON";
  audioToggleBtn.style.cssText = "margin-top: 10px; padding: 5px 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; touch-action: manipulation;";
  
  audioToggleBtn.addEventListener("click", () => {
    // Initialize audio context on first user interaction
    initAudio();
    
    window.audioEnabled = !window.audioEnabled;
    audioToggleBtn.innerText = window.audioEnabled ? "ðŸ”Š Audio: ON" : "ðŸ”‡ Audio: OFF";
    if (!window.audioEnabled) {
      stopAllAudio();
    }
  });
  
  audioToggleBtn.addEventListener("touchend", (e) => {
    e.preventDefault();
    // Initialize audio context on first user interaction
    initAudio();
    
    window.audioEnabled = !window.audioEnabled;
    audioToggleBtn.innerText = window.audioEnabled ? "ðŸ”Š Audio: ON" : "ðŸ”‡ Audio: OFF";
    if (!window.audioEnabled) {
      stopAllAudio();
    }
  });
  
  buttonContainer.appendChild(audioToggleBtn);
  
  slotContainer.appendChild(buttonContainer);

  showMessage(`Level: ${L.name}`);
}

// ---------------- PRECOMPUTE TARGET PATH ----------------
function computeTarget(target) {
  targetPoints = [];
  for (let step = 0; step < 300; step++) {
    let tt = (step / 300) * Math.PI * 2;
    let pos = { x: 0, y: 0 };
    target.forEach(c => {
      pos.x += c.r * Math.cos(c.f * tt + c.p);
      pos.y += c.r * Math.sin(c.f * tt + c.p);
    });
    targetPoints.push(pos);
  }
}

// ---------------- CHECK VICTORY ----------------
function checkAttempt() {
  const activeSlots = Array.from(slotContainer.querySelectorAll(".slot"));
  const activeIDs = activeSlots.map(s => s.dataset.id).filter(id => id); // Get filled slots
  
  const targetCount = levels[currentLevel].target.length;
  if (activeIDs.length !== targetCount) {
    showMessage(`Fill all ${targetCount} slots to check your solution`);
    return;
  }

  // Start drawing the pattern
  startDrawing();
  
  // Update audio for all active circles
  const activeCircles = activeIDs.map(id => circles.find(c => c.id === id));
  updateAllAudio(activeCircles);

  const targetIDs = levels[currentLevel].target.map(c => c.id);
  let correctCircles = 0;
  
  // Check for correct circles (order doesn't matter)
  activeIDs.forEach(id => {
    if (targetIDs.includes(id)) {
      correctCircles++;
    }
  });
  
  // Check if all target circles are present
  const hasAllTargetCircles = targetIDs.every(targetID => activeIDs.includes(targetID));
  
  // Record the attempt (always record, even if incomplete)
  const attempt = {
    circles: activeIDs.map(id => circles.find(c => c.id === id)),
    feedback: {
      correctCircles,
      wrong: targetCount - correctCircles
    }
  };
  attempts.push(attempt);
  
  // Create attempt display
  const historyDiv = document.getElementById('attemptsHistory');
  const attemptDiv = document.createElement('div');
  attemptDiv.className = 'attempt';

  // Add circles
  const circlesDiv = document.createElement('div');
  circlesDiv.className = 'attempt-circles';
  attempt.circles.forEach(circle => {
    const circleDiv = document.createElement('div');
    circleDiv.className = 'attempt-circle';
    circleDiv.style.background = circle.color;
    circlesDiv.appendChild(circleDiv);
  });
  attemptDiv.appendChild(circlesDiv);

  // Add feedback dots
  const feedbackDiv = document.createElement('div');
  feedbackDiv.className = 'feedback-dots';
  
  // Correct circle dots
  for (let i = 0; i < attempt.feedback.correctCircles; i++) {
    const dot = document.createElement('div');
    dot.className = 'feedback-dot correct-place';
    feedbackDiv.appendChild(dot);
  }
  
  // Wrong dots
  for (let i = 0; i < attempt.feedback.wrong; i++) {
    const dot = document.createElement('div');
    dot.className = 'feedback-dot wrong';
    feedbackDiv.appendChild(dot);
  }
  
  attemptDiv.appendChild(feedbackDiv);
  historyDiv.insertBefore(attemptDiv, historyDiv.firstChild);

  showMessage(`Attempt ${attempts.length}: ${correctCircles} correct circles`);
  
  // Handle button replacement for all non-victory cases
  if (correctCircles !== targetCount || !hasAllTargetCircles) {
    // Replace check button with try again button
    const buttonContainer = document.getElementById('buttonContainer');
    const checkBtn = document.getElementById('checkBtn');
    if (buttonContainer && checkBtn) {
      const tryAgainBtn = document.createElement("button");
      tryAgainBtn.id = "tryAgainBtn";
      tryAgainBtn.innerText = "Try Again";
      tryAgainBtn.style.cssText = "padding: 10px 20px; background: #f44; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px;";
      
      const handleTryAgain = () => {
        // Clear slots
        activeSlots.forEach(slot => {
          // Stop any existing animation
          if (slot.animationId) {
            cancelAnimationFrame(slot.animationId);
            slot.animationId = null;
          }
          
          // Clear the slot completely
          slot.innerHTML = '';
          slot.classList.remove('filled');
          slot.classList.remove('locked');
          slot.style.border = '2px dashed #555';
          
          // Restore placeholder
          const placeholder = document.createElement("div");
          placeholder.className = "placeholder";
          placeholder.innerText = "drop";
          slot.appendChild(placeholder);
          
          // Recreate canvas for animation
          const canvas = document.createElement("canvas");
          const isMobile = window.innerWidth <= 600;
          canvas.width = isMobile ? 40 : 80;
          canvas.height = isMobile ? 40 : 80;
          slot.appendChild(canvas);
        });
        
        // Stop drawing epicycles
        stopDrawing();
        
        // Stop all audio
        stopAllAudio();
        
        // Replace try again button with check button
        const newCheckBtn = document.createElement("button");
        newCheckBtn.id = "checkBtn";
        newCheckBtn.innerText = "Check Solution";
        newCheckBtn.style.cssText = "padding: 10px 20px; background: #0ff; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px; touch-action: manipulation;";
        
        // Add both click and touch events for mobile compatibility
        newCheckBtn.addEventListener("click", checkAttempt);
        newCheckBtn.addEventListener("touchend", (e) => {
          e.preventDefault();
          checkAttempt();
        });
        
        buttonContainer.replaceChild(newCheckBtn, tryAgainBtn);
      };
      
      tryAgainBtn.addEventListener("click", handleTryAgain);
      tryAgainBtn.addEventListener("touchend", (e) => {
        e.preventDefault();
        handleTryAgain();
      });
      
      // Animate button transition
      checkBtn.style.transition = "opacity 0.3s";
      checkBtn.style.opacity = "0";
      setTimeout(() => {
        buttonContainer.replaceChild(tryAgainBtn, checkBtn);
      }, 300);
      
      // Lock all slots
      document.querySelectorAll('.slot').forEach(slot => {
        slot.classList.add('locked');
      });
    }
  }
  
  // Check for victory
  if (correctCircles === targetCount && hasAllTargetCircles) {
    triggerVictory();
  }
}

// ---------------- VICTORY ACTION ----------------
function triggerVictory() {
  showMessage("ðŸŽ‰ Correct!");
  
  // Check if this was the last level
  if (currentLevel === levels.length - 1) {
    // Show victory modal
    showVictoryModal();
  } else {
    // Replace check button with next button
    const buttonContainer = document.getElementById('buttonContainer');
    const checkBtn = document.getElementById('checkBtn');
    if (buttonContainer && checkBtn) {
      const nextBtn = document.createElement("button");
      nextBtn.innerText = "Next Level";
      nextBtn.style.cssText = "padding: 10px 20px; background: #0ff; color: #000; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; max-width: 800px;";
      const handleNextLevel = () => {
        currentLevel++;
        loadLevel(currentLevel);
      };
      
      nextBtn.addEventListener("click", handleNextLevel);
      nextBtn.addEventListener("touchend", (e) => {
        e.preventDefault();
        handleNextLevel();
      });
      
      // Animate button transition
      checkBtn.style.transition = "opacity 0.3s";
      checkBtn.style.opacity = "0";
      setTimeout(() => {
        buttonContainer.replaceChild(nextBtn, checkBtn);
      }, 300);
    }
  }
  
  solveBtn.style.display = "none"; // Hide solve when already solved
  glowTimer = 120; // âœ… Canvas glow for 2s
}

// ---------------- NEXT LEVEL ----------------
nextBtn.addEventListener("click", () => {
  currentLevel++;
  if (currentLevel >= levels.length) currentLevel = 0;
  loadLevel(currentLevel);
});

// ---------------- SHOW SOLUTION ----------------
solveBtn.addEventListener("click", () => {
  const target = levels[currentLevel].target;
  const slots = slotContainer.querySelectorAll(".slot");
  slots.forEach((s, i) => {
    s.dataset.id = target[i].id;
    s.innerText = target[i].id;
    s.style.border = "2px solid #fff";
  });
  triggerVictory(); // âœ… Auto win when showing solution
});

// ---------------- MESSAGE UI ----------------
function showMessage(txt) {
  message.innerText = txt;
  message.style.opacity = txt ? 1 : 0;
}

// ---------------- DRAW LOOP ----------------
function drawTargetShape() {
  ctx.clearRect(0, 0, 400, 400);
  ctx.save();
  ctx.translate(200, 200);

  // Target outline
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(targetPoints[0].x, targetPoints[0].y);
  targetPoints.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.stroke();

  ctx.restore();
}

function draw() {
  if (!isDrawing) {
    drawTargetShape();
    return;
  }

  ctx.clearRect(0, 0, 400, 400);
  ctx.save();
  ctx.translate(200, 200);

  // Target outline
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(targetPoints[0].x, targetPoints[0].y);
  targetPoints.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.stroke();

  // Draw active epicycles
  const active = [];
  slotContainer.querySelectorAll(".slot").forEach(s => {
    if (s.dataset.id) {
      const c = circles.find(cc => cc.id === s.dataset.id);
      if (c) active.push(c);
    }
  });

  // Initialize main trail if not exists
  if (!window.mainTrail) {
    window.mainTrail = [];
    window.mainTrailLength = 200; // Longer trail for main canvas
  }
  
  let pos = { x: 0, y: 0 };
  active.forEach(c => {
    // Draw orbit path
    ctx.strokeStyle = "rgba(128,128,128,0.2)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, c.r, 0, Math.PI * 2);
    ctx.stroke();

    const next = { x: pos.x + c.r * Math.cos(c.f * t + c.p),
                   y: pos.y + c.r * Math.sin(c.f * t + c.p) };
    
    // Update audio volume based on Y position (for main canvas)
    updateCircleVolume(c.id, next.y);
    
    // Draw connecting line
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineTo(next.x, next.y);
    ctx.stroke();

    // Draw moving point
    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.arc(next.x, next.y, 3, 0, Math.PI * 2);
    ctx.fill();

    pos = next;
  });
  
  // Add final position to main trail
  window.mainTrail.push({ x: pos.x, y: pos.y, t });
  if (window.mainTrail.length > window.mainTrailLength) {
    window.mainTrail.shift();
  }
  
  // Draw main trail
  if (window.mainTrail.length > 1) {
    // Check if solution is correct
    const targetIDs = levels[currentLevel].target.map(c => c.id);
    const activeIDs = active.map(c => c.id);
    const correctCircles = activeIDs.filter(id => targetIDs.includes(id)).length;
    const isCorrect = correctCircles === targetIDs.length;
    
    // Draw trail with appropriate color
    ctx.strokeStyle = isCorrect ? "rgba(0,255,255,0.8)" : "rgba(255,100,100,0.8)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(window.mainTrail[0].x, window.mainTrail[0].y);
    for (let i = 1; i < window.mainTrail.length; i++) {
      ctx.lineTo(window.mainTrail[i].x, window.mainTrail[i].y);
    }
    ctx.stroke();
  }

  ctx.restore();
  t += 0.01;

  // âœ… Victory Glow
  if (glowTimer > 0) {
    canvas.style.boxShadow = "0 0 20px 5px #0ff";
    glowTimer--;
    if (glowTimer === 0) canvas.style.boxShadow = "none";
  }

  drawAnimationId = requestAnimationFrame(draw);
}

// ---------------- START ----------------
let isDrawing = false;
let drawAnimationId = null;

function startDrawing() {
  if (!isDrawing) {
    isDrawing = true;
    // Clear main trail when starting to draw
    window.mainTrail = [];
    draw();
  }
}

function stopDrawing() {
  isDrawing = false;
  if (drawAnimationId) {
    cancelAnimationFrame(drawAnimationId);
    drawAnimationId = null;
  }
  // Clear main trail when stopping
  window.mainTrail = [];
  // Draw just the target shape
  drawTargetShape();
}

function showVictoryModal() {
  // Create modal overlay
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  
  // Create modal content
  const modal = document.createElement('div');
  modal.className = 'victory-modal';
  
  modal.innerHTML = `
    <div class="victory-title">ðŸŽ‰ Congratulations! ðŸŽ‰</div>
    <div class="victory-message">
      You've attained the Rank of<br>
      <strong>Loop Master!</strong><br><br>
      You've mastered the art of epicycles and can now create any shape with the power of rotating circles!
    </div>
    <a href="index.html" class="victory-btn">ðŸ  Return Home</a>
  `;
  
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // Add click outside to close (optional)
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
      overlay.remove();
    }
  });
}

loadLevel(0);
draw(); // Start the animation loop (will only show target shape until check)
</script>
</body>
</html>