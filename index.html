<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yay! Yay! Yay! Yay!</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <img src="logo.png" alt="Yay! Yay! Yay! Yay!" class="logo">
    
    <div class="canvas-container">
        <canvas id="demoCanvas" width="400" height="400"></canvas>
        <div id="audioToggle" class="audio-toggle" title="Toggle Audio">ðŸ”Š</div>
    </div>
    
    <div class="container">
        <a href="game.html" class="button">Game</a>
        <div style="display: flex; gap: 20px;">
            <a href="instructions.html" class="button">Instructions</a>
            <a href="playground.html" class="button">Playground</a>
        </div>
    </div>

    <script type="module">
        import { initAudio, updateCircleAudio, updateCircleVolume } from './js/audio.js';

        const canvas = document.getElementById('demoCanvas');
        const ctx = canvas.getContext('2d');
        
        // Demo animation with complex shape
        const demoCircles = [
            { r: 80, f: 1, p: 0, color: '#0f0', index: 0 },
            { r: 50, f: -2, p: 1.2, color: '#ff0', index: 1 },
            { r: 30, f: 3, p: 0.8, color: '#0ff', index: 2 },
            { r: 20, f: -4, p: 2.1, color: '#f0f', index: 3 }
        ];
        
        let t = 0;
        
        function animate() {
            ctx.clearRect(0, 0, 400, 400);
            ctx.save();
            ctx.translate(200, 200);
            
            // Draw the complex pattern
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < 200; i++) {
                const angle = (i / 200) * Math.PI * 2;
                let x = 0, y = 0;
                
                demoCircles.forEach(circle => {
                    x += circle.r * Math.cos(circle.f * angle + circle.p);
                    y += circle.r * Math.sin(circle.f * angle + circle.p);
                });
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Draw chained epicycles
            let pos = { x: 0, y: 0 };
            demoCircles.forEach((circle, index) => {
                // Draw orbit path around current position
                ctx.strokeStyle = "rgba(128,128,128,0.2)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, circle.r, 0, Math.PI * 2);
                ctx.stroke();
                
                // Calculate next position
                const nextX = pos.x + circle.r * Math.cos(circle.f * t + circle.p);
                const nextY = pos.y + circle.r * Math.sin(circle.f * t + circle.p);
                
                // Update audio volume and frequency based on position
                updateCircleVolume(index, nextY, nextX);
                
                // Draw connecting line
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(nextX, nextY);
                ctx.stroke();
                
                // Draw moving point
                ctx.fillStyle = circle.color;
                ctx.beginPath();
                ctx.arc(nextX, nextY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Update position for next circle
                pos = { x: nextX, y: nextY };
            });
            
            ctx.restore();
            
            t += 0.015;
            requestAnimationFrame(animate);
        }
        
        // Initialize audio on user interaction (required for autoplay policies)
        function initializeAudioOnInteraction() {
            if (!audioContext) {
                initAudio();
                // Initialize demo audio after a short delay to ensure samples are loaded
                setTimeout(() => {
                    initializeDemoAudio();
                }, 1000);
                // Remove event listeners after first interaction
                document.removeEventListener('click', initializeAudioOnInteraction);
                document.removeEventListener('touchstart', initializeAudioOnInteraction);
                document.removeEventListener('keydown', initializeAudioOnInteraction);
            }
        }
        
        // Audio toggle functionality
        function toggleAudio() {
            window.audioEnabled = !window.audioEnabled;
            const toggleBtn = document.getElementById('audioToggle');
            
            if (window.audioEnabled) {
                toggleBtn.textContent = 'ðŸ”Š';
                toggleBtn.classList.remove('muted');
                toggleBtn.title = 'Mute Audio';
            } else {
                toggleBtn.textContent = 'ðŸ”‡';
                toggleBtn.classList.add('muted');
                toggleBtn.title = 'Unmute Audio';
            }
        }
        
        // Add event listeners for audio initialization
        document.addEventListener('click', initializeAudioOnInteraction);
        document.addEventListener('touchstart', initializeAudioOnInteraction);
        document.addEventListener('keydown', initializeAudioOnInteraction);
        
        // Add event listener for audio toggle button
        document.getElementById('audioToggle').addEventListener('click', function(e) {
            e.stopPropagation();
            toggleAudio();
        });
        
        // Initialize oscillators for demo circles
        function initializeDemoAudio() {
            if (audioContext) {
                demoCircles.forEach(circle => {
                    updateCircleAudio(circle, true);
                });
            }
        }
        
        // Start animation
        animate();
    </script>
</body>
</html>
